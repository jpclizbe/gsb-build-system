#!/bin/bash
# Version: 1.3 GSB Section Build Script
# Copyright (c) 2007 Darren 'Tadgy' Austin <darren (at) gnomeslackbuild.org>
# Copyright (c) 2007 Steve Kennedy <sk238 (at) exeter.ac.uk>
#
# Package name routine partially borrowed from the Slackware upgradepkg tool.
# Copyright 1999  Patrick Volkerding, Moorhead, Minnesota, USA.
# Copyright 2001, 2002, 2003  Slackware Linux, Inc., Concord, California, USA
#
# Licenced under the terms of the GNU General Public Licence version 3.
#

# GSB Metapackages 
#
# These packages are essentially empty, except for a list of 
# package requirements for each section.  They allow users
# to use slapt-get to install by logical section, like
# gsb-desktop, or gsb-extras, etc. 

# Package build list.  Order doesn't matter.
BUILD_ORDER=" 
     gsb-accessibility
     gsb-administration
     gsb-desktop
     gsb-office
     gsb-development
     gsb-multimedia
     gsb-mono
     gsb-themes
     gsb-compiz
     gsb-complete
   "
#

# Section name.
# This should not need to be changed unless the auto detection fails.
SECTION="$( echo ${BASH_SOURCE#*/} | cut -d. -f2 )"

# If the user created an options file, read it if it's not been read already.
[ "$OPTIONSREAD" != "1" -a -r ../gsb.options ] && {
  . ../gsb.options
  export OPTIONSREAD=1
}

#
# Environment Variables
#
export TMP=${TMP:-/tmp}
export LOGSDIR=${GSB_LOGSDIR:-$TMP/gsb-buildlogs}
export PKGDEST=${PKGDEST:-$TMP/gsb-tree/packages}

# There are no binaries in them, so they will only need
# to be noarch.  It's up to the user to ensure they
# have their slapt-get pointed to the proper binary
# repository.  :^)
ARCH=noarch
DISTRO=${DISTRO:-slackware}

## Package variables.  Version is GNOME release version.
BUILD=1
VERSION=2.20.3

## List any packages here that are required to build this package.
## The list is space seperated and case sensitive.  
REQUIRED_PACKAGES="pkgtools"


# Script Variables
CWD=$(pwd)
NOCLEANUP=1
FORCEBUILD=0

# Section Name
SECTION=meta

# 
# Functions 
#

# Prints usage and help 
function usage() {
  cat << EOF
Usage: ${0#*/} [options]

The default behaviour of the build script is to skip any previously 
installed package, and continue building the next package in the 
build order.  This is to avoid accidently updating and removing
of any customized, prebuilt, or Slackware default packages. 

You will need to pass the -update switch to build GSB packages that 
replace any default Slackware package.

Options:  --force   
 
            The package will not be built if a package of the same
            name is already installed, or any of the packages
            required to build are missing.  This option over-rides
            these checks and attempts a build anyway. 

            It cannot be used with the --update switch.

          --update 

            This switch will make the build script test each package
            version as defined in the SlackBuild script against the
            currently installed package.  If there is a difference,
            the script will remove, rebuild, and reinstall the package.

            It cannot be used with the --force switch.

          --no-cleanup   
            
            By default any temporary source, build and package
            directories will be deleted once the package is built.
            This option prevents those files from being removed.

          --no-install 
            
            Build the packages but don't install them.  This should
            only be used for testing individual SlackBuilds. It may
            cause the section build to fail when required packages
            are not installed and the dependency checks fail.

          --help     
 
            Show this help screen.

Options are passed down to the next level SlackBuild where appropriate.

EOF
}

function list_packages() {
  local PACKAGE
  echo "The following packages are built in this section, listed in processing order:"
  ( for PACKAGE in $PACKAGES
    do
      echo -n "$PACKAGE, "
    done ) | sed -e 's/, $//' | fmt -w 74 | sed -e 's/^/    /g'
}

function find_package_files() {
  # $1 = Directory to look for files in [required]
  # $2 = Package name or regex to match.  An empty string matches all.
  # $3 = Package version or regex to match.  An empty string matches all.
  # $4 = Package architecture or regex to match.  An empty string matches all.
  # $5 = Package build tag or regex to match.  An empty string matches all.
  # $6 = File extension or regex to match.  An empty string means no extension.
  # Note: Remember to escape any regex characters used in fixed strings.
  
  [ -z "$1" ] || [ ! -d "$1" ] && return 1
  find $1 -maxdepth 1 -mindepth 1 2>/dev/null | \
    egrep "^.*/(${2:-.*})(-${3:-[^-]*})(-${4:-[^-]*})(-${5:-[^-.]*})($6)$" 2>/dev/null
  return $?
}

function gen_pkg_txt() {
  # $1 = Package file to process [required].

  [ -z "$1" ] || [ ! -e "$1" ] && return 1
  tar xzOf $1 install/slack-desc 2>/dev/null | \
    grep -v "^#" | egrep "[[:alnum:]\+]+\:" >${1%.tgz}.txt
  return $?
}

function gen_pkg_md5() {
  # $1 = Package file to process [required].

  [ -z "$1" ] || [ ! -e "$1" ] && return 1
  ( cd $( dirname $1 ) && md5sum $( basename $1 ) >$1.md5 )
  return $?
}

# Make sure we are in the right directory (you can never trust users..)
cd $( cd ${BASH_SOURCE%/*} ; pwd )

# If the user created an options file, read it.
[ "$OPTIONSREAD" != "1" -a -r ../gsb.options ] && {
  . ../gsb.options
  export OPTIONSREAD=1
}

# Environment.
export TMP=${TMP:-/tmp}
export PKGDEST=${PKGDEST:-$TMP/gsb-tree/packages}
export LOGSDIR=${LOGSDIR:-$TMP/gsb-buildlogs}

# Option defaults.
NOSKIP=0
NOMETAFILES=0
NOPRUNE=0
NOINSTALL=0
UPDATEONLY=0

#
# Command Line Parsing
#
while [ $# -gt 0 ]; do
  if [ "$1" = "-force" ] || [ "$1" = "--force" ]; then
    if [ "$UPDATE" = "1" ]; then
       echo "${0#*/}: The switches --force and --update are mutually exclusive."
       exit 1;
    fi;
    FORCE=1
    SLACKBUILD_ARGS="$SLACKBUILD_ARGS --force"
    shift
  elif [ "$1" = "-no-cleanup" ] || [ "$1" = "--no-cleanup" ]; then
    NOCLEANUP=1
    shift
  elif [ "$1" = "-no-install" ] || [ "$1" = "--no-install" ]; then
    NOINSTALL=1
    shift
  elif [ "$1" = "-update" ] || [ "$1" = "--update" ]; then
    if [ "$FORCE" = "1" ]; then
       echo "${0#*/}: The switches --force and --update are mutually exclusive."
       exit 1;
    fi;
    UPDATE=1
    shift
  elif [ "$1" = "-help" ] || [ "$1" = "--help" ]; then
    usage
    exit 0
  else
    echo "${0#*/}: Unknown option: $1"
    exit 1
  fi
done

# Temporary space, package and log file storage.
mkdir -p $TMP
mkdir -p $PKGDEST
mkdir -p $LOGSDIR
mkdir -p $PKGDEST/$SECTION
mkdir -p $LOGSDIR/$SECTION


# MAIN BUILD 
#

# Build packages (and log output). This is the main loop through
# all the packages listed above.
( for PACKAGE in $BUILD_ORDER

do

if [ -f $CWD/slack-desc.$PACKAGE -a -f $CWD/slack-required.$PACKAGE ]; then

  mkdir -p $TMP/$PACKAGE-$VERSION/install 

  echo "${0##*/}: Compiling metapackage: ${PACKAGE}"

  # Install metapackage description
  if [ -f $CWD/slack-desc.$PACKAGE ]; then
    cat $CWD/slack-desc.$PACKAGE > $TMP/$PACKAGE-$VERSION/install/slack-desc || exit 1
  fi;

  # Install metapackage package list
  if [ -f $CWD/slack-required.$PACKAGE ]; then
    cat $CWD/slack-required.$PACKAGE > $TMP/$PACKAGE-$VERSION/install/slack-required || exit 1
  fi;

  # Install metapackage suggested (if exists)
  if [ -f $CWD/slack-suggests.$PACKAGE ]; then
    cat $CWD/slack-suggests.$PACKAGE > $TMP/$PACKAGE-$VERSION/install/slack-suggests || exit 1
  fi;

  # Create the package
  cd $TMP/$PACKAGE-$VERSION
  makepkg -p -l y -c n $PKGDEST/$SECTION/$PACKAGE-${VERSION//-/_}-$ARCH-$BUILD.tgz 2> /dev/null 1> /dev/null || exit 1

  PRUNE_FILES="$( find_package_files "$PKGDEST/$SECTION" "${PACKAGE//+/\+}" \
      "" "" "" "\.tgz|\.txt|\.tgz\.md5" | grep -v "$( find_package_files \
      "$PKGDEST/$SECTION" "${PACKAGE//+/\+}" "${VERSION//-/_}" "" \
      "$PACKAGE_BUILD" "\.tgz" )" | tr '\n' ' ' )"
    [ ! -z "$PRUNE_FILES" ] && {
      if [ "$NOPRUNE" = "0" ]; then
        echo "${0##*/}: Pruning old $PACKAGE packages from tree."
        rm -f $PRUNE_FILES
      else
        echo
        echo "*********************************************************************"
        echo "*** Warning: not pruning any old '$PACKAGE' files."
        echo "*********************************************************************"
      fi
    }

  if [ "$NOMETAFILES" = "0" ]; then
      echo "${0##*/}: Creating metafiles for '$PACKAGE'..."
      gen_pkg_txt "$( find_package_files "$PKGDEST/$SECTION" "${PACKAGE//+/\+}" \
        "${VERSION//-/_}" "" "$PACKAGE_BUILD" "\.tgz" )" &&
      gen_pkg_md5 "$( find_package_files "$PKGDEST/$SECTION" "${PACKAGE//+/\+}" \
        "${VERSION//-/_}" "" "$PACKAGE_BUILD" "\.tgz" )" || {
        echo
        echo "*********************************************************************"
        echo "*** Error: failed to create metafiles for '$PACKAGE'."
        echo "*********************************************************************"
        exit 1
      }
    else
      echo
      echo "*********************************************************************"
      echo "*** Warning: not creating metafiles for '$PACKAGE'."
      echo "*********************************************************************"
    fi

  ## Cleanup
  [ "$NOCLEANUP" = "0" ] && {
    rm -rf $PKG $TMP/$PACKAGE-$VERSION
    }

else
  echo "${0#*/}: Cannot find $PACKAGE metadata."
  exit 1;

fi;

done;
# Main loop

#
# Log Output
#
) 2>&1 | tee $LOGSDIR/$PACKAGE-$(date +%Y%m%d-%H%M%S).log

# Return the exit status from the sub-shell, not the tee command.
exit ${PIPESTATUS[0]}
