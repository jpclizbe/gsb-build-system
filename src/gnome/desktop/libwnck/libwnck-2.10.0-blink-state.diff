diff -ur libwnck-2.10.0-orig/libwnck/tasklist.c libwnck-2.10.0/libwnck/tasklist.c
--- libwnck-2.10.0-orig/libwnck/tasklist.c	2005-02-28 08:28:20.000000000 +0100
+++ libwnck-2.10.0/libwnck/tasklist.c	2005-04-27 07:34:47.000000000 +0200
@@ -55,6 +55,7 @@
 
 typedef struct _WnckTask        WnckTask;
 typedef struct _WnckTaskClass   WnckTaskClass;
+typedef struct _WnckTaskWindow  WnckTaskWindow;
 
 #define MINI_ICON_SIZE 16
 #define DEFAULT_GROUPING_LIMIT 80
@@ -127,6 +128,12 @@
   GObjectClass parent_class;
 };
 
+struct _WnckTaskWindow
+{
+  WnckTasklist *tasklist;
+  WnckWindow  *window;
+};
+
 struct _WnckTasklistPrivate
 {
   WnckScreen *screen;
@@ -2434,6 +2441,36 @@
   gtk_widget_queue_resize (GTK_WIDGET (task->tasklist));
 }
 
+static gboolean
+urgent_timeout_callback	(void *user_data)
+{
+  WnckTaskWindow *taskwin = user_data;
+  WnckTask *task; 
+  WnckWindowState state;
+
+  task = (g_hash_table_lookup (taskwin->tasklist->priv->win_hash,
+ 				taskwin->window));
+  if (task == NULL)
+    {
+      g_free(taskwin);
+      return FALSE;
+    }
+
+   state = wnck_window_get_state (task->window);
+
+   if (state & WNCK_WINDOW_STATE_URGENT)
+     {
+       if (GTK_WIDGET_STATE(task->button) != GTK_STATE_SELECTED)
+         gtk_widget_set_state(task->button, GTK_STATE_SELECTED);
+       else
+         gtk_widget_set_state(task->button, GTK_STATE_NORMAL);
+     }
+   else
+     g_free(taskwin);
+
+   return (state & WNCK_WINDOW_STATE_URGENT);
+}
+ 
 static void
 wnck_task_state_changed (WnckWindow     *window,
 			 WnckWindowState changed_mask,
@@ -2441,7 +2478,7 @@
 			 gpointer        data)
 {
   WnckTasklist *tasklist = WNCK_TASKLIST (data);
-
+ 
   if (changed_mask & WNCK_WINDOW_STATE_SKIP_TASKLIST)
     {
       wnck_tasklist_update_lists  (tasklist);
@@ -2469,7 +2506,25 @@
 	    wnck_task_update_visible_state (class_group_task);
 	}
     }
-    
+  if (changed_mask & WNCK_WINDOW_STATE_URGENT)
+    {
+      WnckTask *win_task;
+      WnckTaskWindow *taskwin;
+       
+      win_task = g_hash_table_lookup (tasklist->priv->win_hash, window);
+
+	  if (win_task)
+	    {
+	      if (new_state & WNCK_WINDOW_STATE_URGENT)
+	        {
+	          taskwin = g_new0 (WnckTaskWindow, 1);
+	          taskwin->tasklist = tasklist;
+	          taskwin->window = window;
+	     
+	          g_timeout_add (1000, urgent_timeout_callback, taskwin);
+	        }
+	    }
+    }
 }
 
 static void
@@ -3000,7 +3055,6 @@
         tasklist->priv->startup_sequences =
           g_list_prepend (tasklist->priv->startup_sequences,
                           task);
-
         if (tasklist->priv->startup_sequence_timeout == 0)
           {
             tasklist->priv->startup_sequence_timeout =
diff -ur libwnck-2.10.0-orig/libwnck/window.c libwnck-2.10.0/libwnck/window.c
--- libwnck-2.10.0-orig/libwnck/window.c	2005-02-21 00:30:35.000000000 +0100
+++ libwnck-2.10.0/libwnck/window.c	2005-04-27 07:34:47.000000000 +0200
@@ -47,7 +47,8 @@
     ((window)->priv->is_sticky           << 6) |        \
     ((window)->priv->is_hidden           << 7) |        \
     ((window)->priv->is_fullscreen       << 8) |        \
-    ((window)->priv->demands_attention   << 9) )
+    ((window)->priv->demands_attention   << 9) |        \
+    ((window)->priv->is_urgent           << 10) )
 
 struct _WnckWindowPrivate
 {
@@ -100,6 +101,7 @@
   guint is_hidden : 1;
   guint is_fullscreen : 1;
   guint demands_attention : 1;
+  guint is_urgent : 1;
 
   /* _NET_WM_STATE_HIDDEN doesn't map directly into an
    * externally-visible state (it determines the WM_STATE
@@ -125,6 +127,7 @@
   guint need_update_transient_for : 1;
   guint need_update_startup_id : 1;
   guint need_update_wmclass : 1;
+  guint need_update_wmhints : 1;
 };
 
 enum {
@@ -404,6 +407,7 @@
   window->priv->need_update_transient_for = TRUE;
   window->priv->need_update_startup_id = TRUE;
   window->priv->need_update_wmclass = TRUE;
+  window->priv->need_update_wmhints = TRUE;
   force_update_now (window);
 
   return window;
@@ -1616,14 +1620,18 @@
   else if (xevent->xproperty.atom ==
            _wnck_atom_get ("_NET_WM_ICON") ||
            xevent->xproperty.atom ==
-           _wnck_atom_get ("KWM_WIN_ICON") ||
-           xevent->xproperty.atom ==
-           _wnck_atom_get ("WM_HINTS"))
+           _wnck_atom_get ("KWM_WIN_ICON"))
     {
       _wnck_icon_cache_property_changed (window->priv->icon_cache,
                                          xevent->xproperty.atom);
       queue_update (window);
     }
+  else if (xevent->xproperty.atom ==
+  	       _wnck_atom_get ("WM_HINTS"))
+    {
+      window->priv->need_update_wmhints = TRUE;
+      queue_update (window);
+    }
 }
 
 void
@@ -2089,6 +2097,18 @@
 }
 
 static void
+update_wmhints (WnckWindow *window)
+{
+  gboolean retval;
+  if (!window->priv->need_update_wmhints)
+    return;
+
+  window->priv->need_update_wmhints = FALSE;
+  retval = _wnck_read_hints(window->priv->xwindow);
+  window->priv->is_urgent = (retval ? 1 : 0);
+}
+
+static void
 force_update_now (WnckWindow *window)
 {
   WnckWindowState old_state;
@@ -2143,6 +2163,7 @@
 
   update_startup_id (window);    /* no side effects */
   update_wmclass (window);
+  update_wmhints (window);
   update_transient_for (window); /* wintype needs this to be first */
   update_wintype (window);
   update_wm_state (window);
@@ -2157,8 +2178,9 @@
   new_state = COMPRESS_STATE (window);
 
   if (old_state != new_state)
+  {
     emit_state_changed (window, old_state ^ new_state, new_state);
-
+}
   if (old_actions != window->priv->actions)
     emit_actions_changed (window, old_actions ^ window->priv->actions,
                           window->priv->actions);
diff -ur libwnck-2.10.0-orig/libwnck/window.h libwnck-2.10.0/libwnck/window.h
--- libwnck-2.10.0-orig/libwnck/window.h	2005-02-21 00:30:35.000000000 +0100
+++ libwnck-2.10.0/libwnck/window.h	2005-04-27 07:34:47.000000000 +0200
@@ -43,7 +43,8 @@
   WNCK_WINDOW_STATE_STICKY                 = 1 << 6,
   WNCK_WINDOW_STATE_HIDDEN                 = 1 << 7,
   WNCK_WINDOW_STATE_FULLSCREEN             = 1 << 8,
-  WNCK_WINDOW_STATE_DEMANDS_ATTENTION      = 1 << 9
+  WNCK_WINDOW_STATE_DEMANDS_ATTENTION      = 1 << 9,
+  WNCK_WINDOW_STATE_URGENT                 = 1 << 10
 } WnckWindowState;
 
 typedef enum
diff -ur libwnck-2.10.0-orig/libwnck/xutils.c libwnck-2.10.0/libwnck/xutils.c
--- libwnck-2.10.0-orig/libwnck/xutils.c	2005-02-21 00:30:35.000000000 +0100
+++ libwnck-2.10.0/libwnck/xutils.c	2005-04-27 07:34:47.000000000 +0200
@@ -1981,6 +1981,28 @@
 }
 
 gboolean
+_wnck_read_hints (Window xwindow)
+{
+  XWMHints *hints;
+  gboolean retval;
+ 
+  retval = FALSE;
+ 
+  _wnck_error_trap_push ();
+  hints = XGetWMHints (gdk_display, xwindow);
+  _wnck_error_trap_pop ();
+
+  if (hints)
+    {
+      retval  = (hints->flags & XUrgencyHint);
+      XFree (hints);
+      hints = NULL;
+	}
+
+  return retval;
+}
+ 
+gboolean
 _wnck_read_icons (Window         xwindow,
                   WnckIconCache *icon_cache,
                   GdkPixbuf    **iconp,
diff -ur libwnck-2.10.0-orig/libwnck/xutils.h libwnck-2.10.0/libwnck/xutils.h
--- libwnck-2.10.0-orig/libwnck/xutils.h	2005-02-21 00:30:35.000000000 +0100
+++ libwnck-2.10.0/libwnck/xutils.h	2005-04-27 07:34:47.000000000 +0200
@@ -140,6 +140,7 @@
 void           _wnck_icon_cache_set_want_fallback    (WnckIconCache *icon_cache,
                                                       gboolean       setting);
 gboolean       _wnck_icon_cache_get_is_fallback      (WnckIconCache *icon_cache);
+gboolean _wnck_read_hints         (Window          xwindow);
 
 gboolean _wnck_read_icons         (Window          xwindow,
                                    WnckIconCache  *icon_cache,

